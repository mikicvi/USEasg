model InvoiceProcessing


class Customer
    attributes
        id  : String
        firstName : String
        lastName : String
        address1 : String
        address2 : String
        city : String
        state : String
        zip : String
        telHome : String
        telWork : String

end


class Invoice 
    attributes
        number : String
        amount : Real

end


class ReceivablesAccount
    attributes
        number : String
        currentBalance : Real
        day30Balance : Real
        day60Balance : Real
        day90Balance : Real
        day120Balance : Real
        collections : Real

end


class ARProcessor
    operations
    ProcessInvoices(arAccount : ReceivablesAccount)
        begin
            for invoice in arAccount.unprocessedInvoices do
                if invoice.amount > 0 then
                    arAccount.currentBalance := arAccount.currentBalance + invoice.amount;
                    delete (arAccount, invoice) from RecAcctToInvoiceUnproc;
                    insert (arAccount, invoice) into RecAcctToInvoiceProcc;
                end;
            end
        end
    EndOfMonthUpdate(arAccount : ReceivablesAccount)
        begin
            arAccount.day120Balance := arAccount.day90Balance;
            arAccount.day90Balance := arAccount.day60Balance;
            arAccount.day60Balance := arAccount.day30Balance;
            arAccount.day30Balance := arAccount.currentBalance;
            arAccount.currentBalance := 0;
        end
end



association CustToRecAcct between 
    Customer [1] role customer
    ReceivablesAccount [0..1] 

end

association RecAcctToInvoiceUnproc between
    ReceivablesAccount [0..1] role unprocc
    Invoice [0..*] role unprocessedInvoices
end

association RecAcctToInvoiceProcc between
    ReceivablesAccount [0..1] role procc
    Invoice [0..*] role processedInvoices
end

constraints
--receivablesAccount invariant
--an invoice cannot be both unprocessed and processed
context ReceivablesAccount inv notboth:
    self.unprocessedInvoices->intersection(self.processedInvoices)->isEmpty()

context ReceivablesAccount inv InvoiceNumCheck:
    self.number.size() = 6

--ARProcessor::ProcessInvoices pre-conditions
--There must be some unprocessedInvoices
--need to change later
context ARProcessor::ProcessInvoices (arAccount:ReceivablesAccount) pre unprocessedInvoicesExist:
    arAccount.unprocessedInvoices->notEmpty()

--ARProcessor::ProcessInvoices post-conditions
--unprocessed invoices become processedInvocies
context ARProcessor::ProcessInvoices(arAccount:ReceivablesAccount) post unprocessedBecomeProcessed:
    arAccount.unprocessedInvoices->isEmpty() and
    --processed invocies includes unprocessed invoices in pre-state
    arAccount.processedInvoices->includesAll(arAccount.unprocessedInvoices@pre)

--ARProcessor::EndOfMonthUpdate pre conditions
--there are no unprocessed invoices

context ARProcessor::EndOfMonthUpdate(arAccount:ReceivablesAccount) pre noUnprocessedInvoices:
    arAccount.unprocessedInvoices->isEmpty()

--ARProcessor::EndOfMonthUpdate post conditions
context ARProcessor::EndOfMonthUpdate(arAccount:ReceivablesAccount) post balancesUpdated:
    arAccount.day120Balance = arAccount.day90Balance@pre and
    arAccount.day90Balance = arAccount.day60Balance@pre and
    arAccount.day60Balance = arAccount.day30Balance@pre and
    arAccount.day30Balance = arAccount.currentBalance@pre and
    arAccount.currentBalance = 0

